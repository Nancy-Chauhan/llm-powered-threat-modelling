import PDFDocument from 'pdfkit';
import type { ThreatModelSelect, ContextFileSelect } from '../db/schema';
import {
  SEVERITY_COLORS,
  CATEGORY_LABELS,
  type RiskSeverity,
  type RiskCategory,
} from '@threat-modeling/shared';

interface Threat {
  id: string;
  title: string;
  description: string;
  category: RiskCategory;
  severity: RiskSeverity;
  likelihood: number;
  impact: number;
  riskScore: number;
  affectedComponents: string[];
  attackVector?: string;
  mitigations: {
    id: string;
    description: string;
    priority: string;
    effort: string;
    status: string;
  }[];
}

export function generateMarkdownReport(
  model: ThreatModelSelect,
  files: ContextFileSelect[]
): string {
  const threats = (model.threats || []) as Threat[];
  const recommendations = (model.recommendations || []) as string[];
  const questionsAnswers = (model.questionsAnswers || []) as Array<{
    question: string;
    answer: string;
    category?: string;
  }>;

  let md = `# Threat Model Report: ${model.title}\n\n`;
  md += `**Generated:** ${new Date().toISOString()}\n`;
  md += `**Status:** ${model.status}\n\n`;

  if (model.description) {
    md += `## Overview\n${model.description}\n\n`;
  }

  if (model.summary) {
    md += `## Executive Summary\n${model.summary}\n\n`;
  }

  // Threat Summary Table
  md += `## Threat Summary\n\n`;
  md += `| # | Threat | Category | Severity | Risk Score |\n`;
  md += `|---|--------|----------|----------|------------|\n`;
  threats.forEach((threat, i) => {
    md += `| ${i + 1} | ${threat.title} | ${CATEGORY_LABELS[threat.category] || threat.category} | ${threat.severity.toUpperCase()} | ${threat.riskScore}/25 |\n`;
  });
  md += '\n';

  // Detailed Threats
  md += `## Detailed Threat Analysis\n\n`;
  threats.forEach((threat, i) => {
    md += `### ${i + 1}. ${threat.title}\n\n`;
    md += `**Category:** ${CATEGORY_LABELS[threat.category] || threat.category}\n`;
    md += `**Severity:** ${threat.severity.toUpperCase()}\n`;
    md += `**Likelihood:** ${threat.likelihood}/5 | **Impact:** ${threat.impact}/5 | **Risk Score:** ${threat.riskScore}/25\n\n`;
    md += `**Description:**\n${threat.description}\n\n`;

    if (threat.attackVector) {
      md += `**Attack Vector:**\n${threat.attackVector}\n\n`;
    }

    if (threat.affectedComponents.length > 0) {
      md += `**Affected Components:** ${threat.affectedComponents.join(', ')}\n\n`;
    }

    if (threat.mitigations.length > 0) {
      md += `**Mitigations:**\n`;
      threat.mitigations.forEach((m) => {
        md += `- [${m.priority.toUpperCase()}] ${m.description} *(Effort: ${m.effort})*\n`;
      });
      md += '\n';
    }
    md += '---\n\n';
  });

  // Recommendations
  if (recommendations.length > 0) {
    md += `## Recommendations\n\n`;
    recommendations.forEach((rec, i) => {
      md += `${i + 1}. ${rec}\n`;
    });
    md += '\n';
  }

  // Context Information
  md += `## Context Information\n\n`;

  if (model.systemDescription) {
    md += `### System Description\n${model.systemDescription}\n\n`;
  }

  if (questionsAnswers.length > 0) {
    md += `### Security Questionnaire\n\n`;
    questionsAnswers.forEach((qa) => {
      md += `**Q: ${qa.question}**\n`;
      md += `A: ${qa.answer}\n\n`;
    });
  }

  if (files.length > 0) {
    md += `### Uploaded Context Files\n\n`;
    files.forEach((f) => {
      md += `- ${f.originalName} (${f.fileType})\n`;
    });
    md += '\n';
  }

  md += `---\n*Generated by Threat Modeling Dashboard*\n`;

  return md;
}

export function generateJsonExport(
  model: ThreatModelSelect,
  files: ContextFileSelect[]
): object {
  return {
    id: model.id,
    title: model.title,
    description: model.description,
    status: model.status,
    systemDescription: model.systemDescription,
    questionsAnswers: model.questionsAnswers,
    threats: model.threats,
    summary: model.summary,
    recommendations: model.recommendations,
    contextFiles: files.map((f) => ({
      id: f.id,
      filename: f.originalName,
      type: f.fileType,
    })),
    generatedAt: model.generationCompletedAt,
    exportedAt: new Date().toISOString(),
  };
}

export async function generatePdfReport(
  model: ThreatModelSelect,
  files: ContextFileSelect[]
): Promise<Buffer> {
  const threats = (model.threats || []) as Threat[];
  const recommendations = (model.recommendations || []) as string[];
  const questionsAnswers = (model.questionsAnswers || []) as Array<{
    question: string;
    answer: string;
    category?: string;
  }>;

  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    const doc = new PDFDocument({ margin: 50 });

    doc.on('data', (chunk) => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    // Title
    doc.fontSize(24).font('Helvetica-Bold').text(`Threat Model Report`, { align: 'center' });
    doc.fontSize(16).font('Helvetica').text(model.title, { align: 'center' });
    doc.moveDown();

    // Metadata
    doc.fontSize(10).fillColor('#666')
      .text(`Generated: ${new Date().toLocaleDateString()}`)
      .text(`Status: ${model.status}`)
      .fillColor('#000');
    doc.moveDown();

    // Description
    if (model.description) {
      doc.fontSize(14).font('Helvetica-Bold').text('Overview');
      doc.fontSize(11).font('Helvetica').text(model.description);
      doc.moveDown();
    }

    // Executive Summary
    if (model.summary) {
      doc.fontSize(14).font('Helvetica-Bold').text('Executive Summary');
      doc.fontSize(11).font('Helvetica').text(model.summary);
      doc.moveDown();
    }

    // Threat Summary
    doc.fontSize(14).font('Helvetica-Bold').text('Threat Summary');
    doc.moveDown(0.5);

    const severityColors: Record<string, string> = {
      critical: '#dc2626',
      high: '#ea580c',
      medium: '#ca8a04',
      low: '#2563eb',
      info: '#6b7280',
    };

    threats.forEach((threat, i) => {
      const color = severityColors[threat.severity] || '#000';
      doc.fontSize(11).font('Helvetica-Bold')
        .text(`${i + 1}. ${threat.title}`, { continued: true })
        .font('Helvetica').fillColor(color)
        .text(` [${threat.severity.toUpperCase()}]`, { continued: false })
        .fillColor('#000');
      doc.fontSize(10).text(`   Risk Score: ${threat.riskScore}/25 | Category: ${CATEGORY_LABELS[threat.category] || threat.category}`);
    });
    doc.moveDown();

    // Detailed Threats
    doc.addPage();
    doc.fontSize(18).font('Helvetica-Bold').text('Detailed Threat Analysis');
    doc.moveDown();

    threats.forEach((threat, i) => {
      // Check if we need a new page
      if (doc.y > 650) doc.addPage();

      const color = severityColors[threat.severity] || '#000';

      doc.fontSize(13).font('Helvetica-Bold')
        .text(`${i + 1}. ${threat.title}`);

      doc.fontSize(10).fillColor(color).font('Helvetica-Bold')
        .text(`Severity: ${threat.severity.toUpperCase()}`, { continued: true })
        .fillColor('#000').font('Helvetica')
        .text(` | Likelihood: ${threat.likelihood}/5 | Impact: ${threat.impact}/5 | Risk: ${threat.riskScore}/25`);

      doc.moveDown(0.3);
      doc.fontSize(10).text(threat.description);

      if (threat.attackVector) {
        doc.moveDown(0.3);
        doc.font('Helvetica-Bold').text('Attack Vector: ', { continued: true })
          .font('Helvetica').text(threat.attackVector);
      }

      if (threat.affectedComponents.length > 0) {
        doc.font('Helvetica-Bold').text('Affected Components: ', { continued: true })
          .font('Helvetica').text(threat.affectedComponents.join(', '));
      }

      if (threat.mitigations.length > 0) {
        doc.moveDown(0.3);
        doc.font('Helvetica-Bold').text('Mitigations:');
        threat.mitigations.forEach((m) => {
          doc.fontSize(9).font('Helvetica')
            .text(`  â€¢ [${m.priority.toUpperCase()}] ${m.description} (Effort: ${m.effort})`);
        });
      }

      doc.moveDown();
      doc.strokeColor('#ccc').moveTo(50, doc.y).lineTo(550, doc.y).stroke();
      doc.moveDown(0.5);
    });

    // Recommendations
    if (recommendations.length > 0) {
      if (doc.y > 600) doc.addPage();
      doc.fontSize(14).font('Helvetica-Bold').text('Recommendations');
      doc.moveDown(0.5);
      recommendations.forEach((rec, i) => {
        doc.fontSize(10).font('Helvetica').text(`${i + 1}. ${rec}`);
      });
      doc.moveDown();
    }

    // Context
    if (model.systemDescription || questionsAnswers.length > 0) {
      if (doc.y > 550) doc.addPage();
      doc.fontSize(14).font('Helvetica-Bold').text('Context Information');
      doc.moveDown(0.5);

      if (model.systemDescription) {
        doc.fontSize(11).font('Helvetica-Bold').text('System Description');
        doc.fontSize(10).font('Helvetica').text(model.systemDescription);
        doc.moveDown();
      }
    }

    // Footer
    doc.fontSize(8).fillColor('#999')
      .text('Generated by Threat Modeling Dashboard', 50, 750, { align: 'center' });

    doc.end();
  });
}
