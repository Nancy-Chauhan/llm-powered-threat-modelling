import type { ThreatModelSelect, ContextFileSelect } from '../db/schema';
import {
  SEVERITY_COLORS,
  CATEGORY_LABELS,
  type RiskSeverity,
  type RiskCategory,
} from '@threat-modeling/shared';

interface Threat {
  id: string;
  title: string;
  description: string;
  category: RiskCategory;
  severity: RiskSeverity;
  likelihood: number;
  impact: number;
  riskScore: number;
  affectedComponents: string[];
  attackVector?: string;
  mitigations: {
    id: string;
    description: string;
    priority: string;
    effort: string;
    status: string;
  }[];
}

export function generateMarkdownReport(
  model: ThreatModelSelect,
  files: ContextFileSelect[]
): string {
  const threats = (model.threats || []) as Threat[];
  const recommendations = (model.recommendations || []) as string[];
  const questionsAnswers = (model.questionsAnswers || []) as Array<{
    question: string;
    answer: string;
    category?: string;
  }>;

  let md = `# Threat Model Report: ${model.title}\n\n`;
  md += `**Generated:** ${new Date().toISOString()}\n`;
  md += `**Status:** ${model.status}\n\n`;

  if (model.description) {
    md += `## Overview\n${model.description}\n\n`;
  }

  if (model.summary) {
    md += `## Executive Summary\n${model.summary}\n\n`;
  }

  // Threat Summary Table
  md += `## Threat Summary\n\n`;
  md += `| # | Threat | Category | Severity | Risk Score |\n`;
  md += `|---|--------|----------|----------|------------|\n`;
  threats.forEach((threat, i) => {
    md += `| ${i + 1} | ${threat.title} | ${CATEGORY_LABELS[threat.category] || threat.category} | ${threat.severity.toUpperCase()} | ${threat.riskScore}/25 |\n`;
  });
  md += '\n';

  // Detailed Threats
  md += `## Detailed Threat Analysis\n\n`;
  threats.forEach((threat, i) => {
    md += `### ${i + 1}. ${threat.title}\n\n`;
    md += `**Category:** ${CATEGORY_LABELS[threat.category] || threat.category}\n`;
    md += `**Severity:** ${threat.severity.toUpperCase()}\n`;
    md += `**Likelihood:** ${threat.likelihood}/5 | **Impact:** ${threat.impact}/5 | **Risk Score:** ${threat.riskScore}/25\n\n`;
    md += `**Description:**\n${threat.description}\n\n`;

    if (threat.attackVector) {
      md += `**Attack Vector:**\n${threat.attackVector}\n\n`;
    }

    if (threat.affectedComponents.length > 0) {
      md += `**Affected Components:** ${threat.affectedComponents.join(', ')}\n\n`;
    }

    if (threat.mitigations.length > 0) {
      md += `**Mitigations:**\n`;
      threat.mitigations.forEach((m) => {
        md += `- [${m.priority.toUpperCase()}] ${m.description} *(Effort: ${m.effort})*\n`;
      });
      md += '\n';
    }
    md += '---\n\n';
  });

  // Recommendations
  if (recommendations.length > 0) {
    md += `## Recommendations\n\n`;
    recommendations.forEach((rec, i) => {
      md += `${i + 1}. ${rec}\n`;
    });
    md += '\n';
  }

  // Context Information
  md += `## Context Information\n\n`;

  if (model.systemDescription) {
    md += `### System Description\n${model.systemDescription}\n\n`;
  }

  if (questionsAnswers.length > 0) {
    md += `### Security Questionnaire\n\n`;
    questionsAnswers.forEach((qa) => {
      md += `**Q: ${qa.question}**\n`;
      md += `A: ${qa.answer}\n\n`;
    });
  }

  if (files.length > 0) {
    md += `### Uploaded Context Files\n\n`;
    files.forEach((f) => {
      md += `- ${f.originalName} (${f.fileType})\n`;
    });
    md += '\n';
  }

  md += `---\n*Generated by Threat Modeling Dashboard*\n`;

  return md;
}

export function generateJsonExport(
  model: ThreatModelSelect,
  files: ContextFileSelect[]
): object {
  return {
    id: model.id,
    title: model.title,
    description: model.description,
    status: model.status,
    systemDescription: model.systemDescription,
    questionsAnswers: model.questionsAnswers,
    threats: model.threats,
    summary: model.summary,
    recommendations: model.recommendations,
    contextFiles: files.map((f) => ({
      id: f.id,
      filename: f.originalName,
      type: f.fileType,
    })),
    generatedAt: model.generationCompletedAt,
    exportedAt: new Date().toISOString(),
  };
}
